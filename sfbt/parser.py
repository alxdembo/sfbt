import json
import os

import networkx as nx
import yaml
from dbt.graph import GraphQueue

CONFIG_YAML = 'config.yaml'
TEMPLATE_YAML = 'template.yaml'
TARGET_MANIFEST_JSON = 'target/manifest.json'
GRAPH_GPICKLE = "target/graph.gpickle"
statemachine_folder = ".aws_autogenerated/statemachine"

# RUN_CONFIG = {
#     'model': {
#         'triggering_event': {'params', 'execution_group'},
#         'function_arn': 'arn:aws:lambda:eu-west-2:1234:function:1234',
#     },
#     'test': {
#         'triggering_event': {'params', 'execution_group'},
#         'function_arn': 'arn:aws:lambda:eu-west-2:1234:function:1234',
#     }
# }

with open(CONFIG_YAML) as f:
    RUN_CONFIG = yaml.load(f, Loader=yaml.FullLoader)


def parse_step(graph, function_arn):
    result = {
        'Comment': 'Autogenerated',
        'StartAt': 'Parallel-0',
        'States': {
            'Parallel-' + str(n): {
                'Type': 'Parallel',
                'Next': 'Parallel-' + str(n + 1),
                'Branches': [
                    {
                        'StartAt': i,
                        'States': {
                            'Type': 'Task',
                            'Resource': function_arn,
                            'Parameters': {},
                            'End': True
                        }
                    } for i in m
                ]
            } for n, m in enumerate(graph)
        },
    }

    last_item = list(result['States'])[-1]

    del result['States'][last_item]['Next']
    result['States'][last_item]['End'] = True

    return result


def write_sam_template():
    sam_template = {
        "AWSTemplateFormatVersion": "2010-09-09",
        "Transform": "AWS::Serverless-2016-10-31",
        "Description": "Autogenerated",
        "Resources": [{
            k + 'Orchestrator': {
                "Type": "AWS::Serverless::StateMachine",
                "Properties": {
                    "Name": k + 'Orchestrator',
                    'DefinitionUri': vals['definition_uri'],
                    'Policies': [{
                        'LambdaInvokePolicy': {
                            'FunctionName': vals['function_arn'].split(":function:")[1]
                        }
                    }]
                }
            }
        } for k, vals in RUN_CONFIG.items()]
    }

    with open(TEMPLATE_YAML, 'w') as f:
        f.write(yaml.dump(sam_template))


def parse():
    with open(TARGET_MANIFEST_JSON) as f:
        manifest = json.loads(f.read())

    os.makedirs(statemachine_folder, exist_ok=True)

    for resource_type, v in RUN_CONFIG.items():
        graph = nx.read_gpickle(GRAPH_GPICKLE)
        node_list = list(graph.nodes)

        for node_name in node_list:
            node = graph.nodes[node_name]
            if node['resource_type'] != resource_type:
                graph.remove_node(node_name)

        graph_sorted = list(GraphQueue._grouped_topological_sort(graph))

        models = parse_step(graph_sorted, v['function_arn'])

        RUN_CONFIG[resource_type]['definition_uri'] = f'./{statemachine_folder}/{resource_type}.asl.yaml'

        with open(RUN_CONFIG[resource_type]['definition_uri'], 'w') as f:
            f.write(yaml.dump(models))

    write_sam_template()
